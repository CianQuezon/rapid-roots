"""
Codegen function for vectorised solvers

Author: Cian Quezon
"""

import numpy as np
import numpy.typing as npt

from numba import njit, prange
from typing import Callable, Tuple, Union
from meteorological_equations.math.solvers._enums import MethodType
from meteorological_equations.shared._enum_tools import parse_enum

def generate_vectorised_solver(scalar_func: Callable[[float], float], num_params: int,
                               method_type: Union[MethodType, str]) -> Callable[[npt.ArrayLike], npt.NDArray[np.float64]]:
    """
    Generates vectorised code for scalar solvers. This solves the problem of having an unspecified number of 
    parameters making the vectorised solvers generalised while using prange. Prange does not allow dynamic unpacking of tuples.

    Args:
        - scalar_func(Callable[[float], float]) = solver scalar function
        - num_params(int) = number of parameters of the function passed
        - method_type(Union[str, MethodType]) = Type of solver method template to be generated by codegen

    Returns:
        - Codegen Function for vectorised operation    
    """

    scalar_name = scalar_func.__name__

    method_type = parse_enum(method_type, MethodType)

    if num_params > 0:
        param_names = ', '.join([f'p{i}' for i in range(num_params)])
        param_extracts = ', '.join([f'func_params[:, {i}]' for i in range(num_params)])
        param_indices = ', '.join([f'p{i}[i]' for i in range(num_params)])
        param_declaration = f"{param_names} = {param_extracts}"
        param_call = f", {param_indices}"

    else:
        param_declaration = ""
        param_call = ""

    if method_type == MethodType.OPEN:
        code = f"""

@njit(parallel = True)
def _open_solver_generated(func, func_prime, func_params, x0, tol, max_iter):
    
    n = len(x0)
    root_arr = np.empty(n, dtype=np.float64)
    iterations_arr = np.empty(n, dtype=np.int64)
    converged_flag_arr = np.empty(n, dtype=np.bool_)

    {param_declaration}

    for i in prange(n):
        root, iteration, converged_flag = {scalar_name}(
            func, func_prime, x0[i], tol, max_iter
            {param_call}
        )
        root_arr[i] = root
        iterations_arr[i] = iteration
        converged_flag_arr[i] = converged_flag

    return root_arr, iterations_arr, converged_flag_arr
"""
        func_name = '_open_solver_generated'
        
    elif method_type == MethodType.BRACKET:
        code = f"""

@njit(parallel = True)
def _bracket_solver_generated(func, func_params, a, b, tol, max_iter):
    
    n = len(a)
    root_arr = np.empty(n, dtype=np.float64)
    iterations_arr = np.empty(n, dtype=np.int64)
    converged_flag_arr = np.empty(n, dtype=np.bool_)

    {param_declaration}

    for i in prange(n):
        root, iteration, converged_flag = {scalar_name}(
            func, a[i], b[i], tol, max_iter
            {param_call}
        )
        root_arr[i] = root
        iterations_arr[i] = iteration
        converged_flag_arr[i] = converged_flag

    return root_arr, iterations_arr, converged_flag_arr
"""
        func_name = '_bracket_solver_generated'
    
    else:
        raise ValueError(f"Unsupported method type: {method_type.value}")
    
    namespace = {
        'njit': njit,
        'prange': prange,
        'np': np,
        scalar_name: scalar_func
    }
        
    exec(code, namespace)
    return namespace[func_name]
    

